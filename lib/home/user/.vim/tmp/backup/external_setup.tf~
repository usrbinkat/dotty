/*
  This module create the AWS public access environment for OpenShift which is 
  used to access the internal AWS components and intiial deployment of the cluster.
  Each security group in the VPC is modified to add SSH access from the bastion server
  One of the outputs of this module is the exact SSH command you can use to login to the bastion server
*/

resource "aws_instance" "bastion-node" {
  count         = var.external_management_access ? 1 : 0
  ami           = var.bastion_config.ami
  instance_type = var.bastion_config.type
  subnet_id     = aws_subnet.public-subnet[0].id
  region        = var.aws_region

  // RH CoreOS user-data | TODO Convert from data string to file path string
  user_data = "{\"ignition\":{\"config\":{},\"security\":{\"tls\":{}},\"timeouts\":{},\"version\":\"2.2.0\"},\"networkd\":{},\"passwd\":{\"users\":[{\"name\":\"core\",\"sshAuthorizedKeys\":[\"${trimspace(file(var.bastion_ssh_public_key_file_path))}\"]}]},\"storage\":{},\"systemd\":{}}"

  root_block_device { volume_size = var.bastion_config.disk }
  vpc_security_group_ids = [aws_security_group.public-sg[0].id]
  tags = merge(
    var.default_tags,
    map(
      "Name", "${var.infrastructure_id}-cloudctl-node",
      "kubernetes.io/cluster/${var.infrastructure_id}", "owned"
    )
  )
}

resource "aws_route_table_association" "route_net" {
  region        = var.aws_region
  count = (var.external_management_access == true) ? length(var.aws_availability_zones) : 0
  route_table_id = aws_route_table.public-route-table[0].id
  subnet_id      = aws_subnet.public-subnet[count.index].id
}

resource "aws_subnet" "public-subnet" {
  region        = var.aws_region
  count                   = (var.external_management_access == true) ? length(var.aws_availability_zones) : 0
  vpc_id                  = var.private_vpc_id
  cidr_block              = var.vpc_public_subnet_cidr[count.index]
  availability_zone       = var.aws_availability_zones[count.index]
  map_public_ip_on_launch = true

  tags = merge(
    var.default_tags,
    map(
      "Name", format("${var.infrastructure_id}-public-%s", format("%s%s", element(list(var.aws_region), 0), element(var.aws_azs, 0))),
      "kubernetes.io/cluster/${var.infrastructure_id}", "owned"
    )
  )
}

resource "aws_route_table" "public-route-table" {
  count  = var.external_management_access ? 1 : 0
  vpc_id = var.private_vpc_id
  tags = merge(
    var.default_tags,
    map(
      "Name", "${var.infrastructure_id}-public-rtbl",
    "kubernetes.io/cluster/${var.infrastructure_id}", "owned")
  )
  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.inet-gateway[0].id
  }
}

resource "aws_route_table_association" "public_route_table_assoc" {
  count          = var.external_management_access ? 1 : 0
  subnet_id      = aws_subnet.public-subnet[0].id
  route_table_id = aws_route_table.public-route-table[0].id
}

resource "aws_internet_gateway" "inet-gateway" {
  region        = var.aws_region
  count  = var.external_management_access ? 1 : 0
  vpc_id = var.private_vpc_id

  tags = merge(
    var.default_tags,
    map(
      "Name", "${var.infrastructure_id}-public-inet-gw",
      "kubernetes.io/cluster/${var.infrastructure_id}", "owned"
    )
  )
}

// public Security Group and SG Rules
resource "aws_security_group" "public-sg" {
  region        = var.aws_region
  count  = var.external_management_access ? 1 : 0
  name   = "${var.infrastructure_id}-public-sg"
  vpc_id = var.private_vpc_id

  tags = merge(
    var.default_tags,
    map(
      "Name", "${var.infrastructure_id}-public-sg",
      "kubernetes.io/cluster/${var.infrastructure_id}", "owned"
    )
  )
}

// Allow inbound from anywhere since this is the public SG
resource "aws_security_group_rule" "public_ssh" {
  count = var.external_management_access ? 1 : 0
  type  = "ingress"

  from_port = 22
  to_port   = 22
  protocol  = "tcp"
  cidr_blocks = [
    var.vpc_cidr,
    "0.0.0.0/0"
  ]
  security_group_id = aws_security_group.public-sg[0].id
}

// Allow inbound from anywhere since this is the public SG
resource "aws_security_group_rule" "public_http" {
  count     = var.external_management_access ? 1 : 0
  type      = "ingress"
  from_port = 80
  to_port   = 80
  protocol  = "tcp"
  cidr_blocks = [
    var.vpc_cidr,
    "0.0.0.0/0"
  ]
  security_group_id = aws_security_group.public-sg[0].id
}

resource "aws_security_group_rule" "public_egress" {
  count = var.external_management_access ? 1 : 0
  type  = "egress"
  region        = var.aws_region

  from_port = 0
  to_port   = 0
  protocol  = "all"
  cidr_blocks = [
    "0.0.0.0/0"
  ]

  security_group_id = aws_security_group.public-sg[0].id
}

resource "aws_eip" "nat_eip" {
  region        = var.aws_region
  count = (var.external_cluster_access == true) ? length(var.aws_availability_zones) : 0
  vpc   = true

  tags = merge(
    {
      "Name" = "${var.infrastructure_id}-eip-${var.aws_availability_zones[count.index]}"
    },
    var.default_tags,
  )

  # Terraform does not declare an explicit dependency towards the internet gateway.
  # this can cause the internet gateway to be deleted/detached before the EIPs.
  # https://github.com/coreos/tectonic-installer/issues/1017#issuecomment-307780549
  depends_on = [aws_internet_gateway.inet-gateway[0]]
}

resource "aws_nat_gateway" "nat_gw" {
  count = (var.external_cluster_access == true) ? length(var.aws_availability_zones) : 0

  allocation_id = aws_eip.nat_eip[count.index].id
  subnet_id     = aws_subnet.public-subnet[count.index].id

  tags = merge(
    {
      "Name" = "${var.infrastructure_id}-nat-${var.aws_availability_zones[count.index]}"
    },
    var.default_tags,
  )
}

resource "aws_lb" "api_external" {
  region        = var.aws_region
  count = (var.external_cluster_access == true) ? 1 : 0

  name                             = "${var.infrastructure_id}-external"
  load_balancer_type               = "network"
  subnets                          = aws_subnet.public-subnet.*.id
  internal                         = false
  enable_cross_zone_load_balancing = true

  tags = merge(
    {
      "Name" = "${var.infrastructure_id}-external"
    },
    var.default_tags,
  )

  timeouts {
    create = "20m"
  }

  depends_on = [aws_internet_gateway.inet-gateway]
}

resource "aws_lb_target_group" "api_external" {
  count = (var.external_cluster_access == true) ? 1 : 0

  name     = "${var.infrastructure_id}-6443-ext-tg"
  protocol = "TCP"
  port     = 6443
  vpc_id   = var.private_vpc_id

  target_type = "ip"

  tags = merge(
    {
      "Name" = "${var.infrastructure_id}-6443-ext-tg"
    },
    var.default_tags,
  )

  health_check {
    healthy_threshold   = 2
    unhealthy_threshold = 2
    interval            = 10
    port                = 6443
    protocol            = "HTTPS"
    path                = "/readyz"
  }
}

resource "aws_lb_listener" "api_external_api" {
  count = (var.external_cluster_access == true) ? 1 : 0

  load_balancer_arn = aws_lb.api_external[0].arn
  protocol          = "TCP"
  port              = "6443"
  region        = var.aws_region

  default_action {
    target_group_arn = aws_lb_target_group.api_external[0].arn
    type             = "forward"
  }
}

